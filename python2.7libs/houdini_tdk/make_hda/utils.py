"""
Tool Development Kit for SideFX Houdini
Copyright (C) 2021 Ivan Titov

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

from __future__ import print_function

import os

import hou
from lxml import etree


def makeHDA(source, label, name=None, namespace=None, icon=None,
            tab_sections=None, version='1.0', location='$HOUDINI_USER_PREF_DIR/otls',
            inherit_subnetwork=True, inherit_parm_template_group=True, color=None,
            shape=None):
    location = hou.expandString(location)
    if not os.path.exists(location) or not os.path.isdir(location):
        raise IOError

    new_type_name = ''

    if namespace:
        new_type_name += namespace.replace(' ', '_').lower() + '::'

    if name:
        new_type_name += name.replace(' ', '_').lower()
    else:
        new_type_name += label.replace(' ', '_').lower()

    new_type_name += '::'

    if version:
        new_type_name += version
    else:
        new_type_name += '1.0'

    if isinstance(source, hou.Node):
        source_def = source.type().definition()
    elif isinstance(source, hou.NodeType):
        source_def = source.definition()
    elif isinstance(source, hou.HDADefinition):
        source_def = source
    else:
        raise TypeError('Invalid source type')

    new_hda_file_name = new_type_name.replace(':', '_').replace('.', '_') + '.hda'
    new_hda_file_path = os.path.join(location, new_hda_file_name).replace('\\', '/')
    source_def.copyToHDAFile(new_hda_file_path, new_type_name)

    new_def = hou.hda.definitionsInFile(new_hda_file_path)[0]
    extra_file_options = new_def.extraFileOptions()

    if isinstance(source, hou.Node):
        if inherit_subnetwork:
            new_def.updateFromNode(source)

        if inherit_parm_template_group:
            parm_template_group = source.parmTemplateGroup()
            hou.hda.installFile(new_hda_file_path)
            new_def.setParmTemplateGroup(parm_template_group)
            hou.hda.uninstallFile(new_hda_file_path)

    new_def.setDescription(label)

    if icon:
        new_def.setIcon(icon)

    if tab_sections and tab_sections.strip():
        sections = (section.strip() for section in tab_sections.split(','))
        try:
            tools = new_def.sections()['Tools.shelf']
            content = tools.contents()
            parser = etree.XMLParser(remove_blank_text=True, resolve_entities=False, strip_cdata=False)
            root = etree.fromstring(content.encode('utf-8'), parser)

            tool = root.find('tool')
            for submenu in tool.findall('toolSubmenu'):
                tool.remove(submenu)

            for section in sections:
                submenu = etree.Element('toolSubmenu')
                submenu.text = section
                tool.append(submenu)

            tools.setContents(etree.tostring(root, encoding='utf-8', pretty_print=True))
        except KeyError:
            pass

    if new_def.hasSection('PreFirstCreate') and extra_file_options.get('PreFirstCreate/IsPython'):
        pre_first_create_section = new_def.sections()['PreFirstCreate']
    else:
        pre_first_create_section = new_def.addSection('PreFirstCreate')
        new_def.setExtraFileOption('PreFirstCreate/IsExpr', False)
        new_def.setExtraFileOption('PreFirstCreate/IsScript', True)
        new_def.setExtraFileOption('PreFirstCreate/IsPython', True)

    if color is not None:
        set_default_color_code = ("# Generated by TDK (https://github.com/anvdev/Houdini_TDK)\n"
                                  "kwargs['type'].setDefaultColor(hou.Color({}))\n\n").format(color.getRgbF()[:3])

        content = pre_first_create_section.contents()
        content += set_default_color_code
        pre_first_create_section.setContents(content)

    if shape is not None:
        set_default_shape_code = ("# Generated by TDK(https://github.com/anvdev/Houdini_TDK)\n"
                                  "kwargs['type'].setDefaultShape('{}')\n\n").format(shape)

        content = pre_first_create_section.contents()
        content += set_default_shape_code
        pre_first_create_section.setContents(content)

    return new_def


def copyHDA(source, path, type_name=None, label=None, preserve_source=True):
    if isinstance(source, hou.Node):
        source_def = source.type().definition()
    elif isinstance(source, hou.NodeType):
        source_def = source.definition()
    elif isinstance(source, hou.HDADefinition):
        source_def = source
    else:
        raise TypeError('Invalid source type')

    try:
        hou.hda.definitionsInFile(path)
    except hou.OperationFailed:
        if os.path.exists(path) and os.path.isdir(path):
            if not type_name:
                type_name = source_def.nodeTypeName()

            path = os.path.join(path, type_name.replace(':', '_').replace('.', '_') + '.hda')
        else:
            if not path.endswith('.hda'):
                path = path + '.hda'

    source_def.copyToHDAFile(path, type_name, label)

    if not preserve_source:
        source_def.destroy()


def moveHDA(source, path):
    copyHDA(source, path, preserve_source=False)
